# 西邮Linux兴趣小组2022纳新面试题

感谢 [Zhilu](https://github.com/L33Z22L11) 重新录入题目原件。好人一生平安。

- 本题目只作为`Xiyou Linux兴趣小组`2022纳新面试的有限参考。
- 为节省版面，本试题的程序源码省去了`#include`指令。
- 本试题中的程序源码仅用于考察C语言基础，不应当作为C语言「代码风格」的范例。
- 题目难度随机排列。
- 所有题目编译并运行于`x86_64 GNU/Linux`环境。

> 学长寄语：
> 长期以来，西邮Linux兴趣小组的面试题以难度之高名扬西邮校内。我们作为出题人也清楚的知道这份试题略有难度。请别担心。**若有同学能完成一半的题目，就已经十分优秀。** 其次，相比于题目的答案，我们对你的思路和过程更感兴趣，或许你的答案略有瑕疵，但你正确的思路和对知识的理解足以为你赢得绝大多数的分数。最后，做题的过程也是学习和成长的过程，相信本试题对你更加熟悉的掌握C语言的一定有所帮助。祝你好运。我们FZ103见！

Copyright © 2022 西邮Linux兴趣小组, All Rights Reserved.
本试题使用采用 [知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](http://creativecommons.org/licenses/by-nc-sa/4.0/) 进行许可。

## 0. 我的计算器坏了？！

`2^10 = 1024`对应于十进制的4位，那么`2^10000`对应于十进制的多少位呢?

### 解答

对应十进制的`3011`位。

## 1. printf还能这么玩？

尝试着解释程序的输出。

```c
int main(void) {
    if ((3 + 2 < 2) > (3 + 2 > 2))
        printf("Welcome to Xiyou Linux Group\n");
    else
        printf("%d\n", printf("Xiyou Linux Group - 2%d", printf("")));
}
```
### 分析

程序的输出为
```c
Xiyou Linux Group - 2022
```
### `if()`语句判断

- `3 + 2 < 2`返回0，`3 + 2 > 2`返回1，`0 > 1`返回0，故`if()`语句判断为`false`，执行`else`语句。
- `else`语句

  最里层`printf()`返回值为0，次里层的`printf()`返回值为22，外层的`printf()`打印出22，最终输出结果即为上述。

## 2. 你好你好你好呀！

- 程序的输出有点奇怪，请尝试解释一下程序的输出吧。
- 请谈谈对`sizeof()`及`strlen()`的理解吧。

```c
int main(void) {
    char p0[] = "Hello,Linux";
    char *p1 = "Hello,Linux";
    char p2[11] = "Hello,Linux";
    printf("p0 == p1: %d, strcmp(p0, p2): %d\n", p0 == p1, strcmp(p0, p2));
    printf("sizeof(p0): %zu, sizeof(p1): %zu, sizeof(*p2): %zu\n",
           sizeof(p0), sizeof(p1), sizeof(*p2));
    printf("strlen(p0): %zu, strlen(p1): %zu\n", strlen(p0), strlen(p1));
}
```

### 分析

### 输出结果

```c
p0 == p1: 0, strcmp(p0, p2): -72
sizeof(p0): 12, sizeof(p1): 8, sizeof(*p2): 1
strlen(p0): 11, strlen(p1): 11

```

这个程序展示了字符串数组与指针的区别，并使用 `sizeof()` 和 `strlen()` 来显示它们在内存中的表现。我们来逐步解释输出。

### 1. `p0 == p1: %d, strcmp(p0, p2): %d`
这一行有两个比较：

- **`p0 == p1`**：
  - `p0` 是字符数组，`p1` 是指向字符串字面量的指针。`p0 == p1` 比较的是它们的地址，而不是内容。
  - 由于 `p0` 和 `p1` 指向不同的内存位置（`p0` 是数组的首地址，而 `p1` 是常量区中的字符串字面量地址），所以这个比较的结果为 `0`，即它们的地址不同。

- **`strcmp(p0, p2)`**：
  - `p2` 是字符数组，其大小固定为 11，但初始化时超出了大小限制，因此只会包含 `"Hello,Linu"`（没有末尾的 `x` 和 `\0`）。`strcmp()` 比较两个字符串的内容，发现 `p0` 和 `p2` 不相等，因此返回一个非零值（通常为正或负值，表示不相等）。

### 2. `sizeof(p0): %zu, sizeof(p1): %zu, sizeof(*p2): %zu`
让我们详细看看每个 `sizeof()` 的含义：

- **`sizeof(p0)`**：
  - `p0` 是一个字符数组，`sizeof(p0)` 计算的是整个数组的大小，包括末尾的 `\0`。`"Hello,Linux"` 包括 12 个字符，因此 `sizeof(p0)` 返回 **12**。

- **`sizeof(p1)`**：
  - `p1` 是指向字符串字面量的指针，`sizeof(p1)` 返回的是指针的大小。在 64 位系统中，指针大小通常为 **8** 字节。

- **`sizeof(*p2)`**：
  - `p2` 是一个数组，`*p2` 解引用了数组的首元素。`p2` 中存储的是字符数组，所以 `sizeof(*p2)` 返回的是 `char` 类型的大小，即 **1** 字节。

### 3. `strlen(p0): %zu, strlen(p1): %zu`
这里使用 `strlen()` 来计算字符串的长度（不包括末尾的 `\0`）。

- **`strlen(p0)`**：
  - `p0` 是字符数组，它包含完整的 `"Hello,Linux"`，其长度为 **11**（不包括末尾的 `\0`）。

- **`strlen(p1)`**：
  - `p1` 是指向字符串 `"Hello,Linux"` 的指针，`strlen(p1)` 也是 **11**，因为内容与 `p0` 相同，指向同样的字符串字面量。

### 总结：

- **`sizeof()`** 用来返回变量的实际大小（字节数），对于数组，它返回整个数组的大小；对于指针，它返回指针的大小。
- **`strlen()`** 计算字符串的长度（字符个数，不包括 `\0` 终止符）。


## 3. 换个变量名不行吗？

请结合本题，分别谈谈你对C语言中「全局变量」和「局部变量」的「生命周期」理解。

```c
int a = 3;
void test() {
    int a = 1;
    a += 1;
    {
        int a = a + 1;
        printf("a = %d\n", a);
    }
    printf("a = %d\n", a);
}
int main(void) {
    test();
    printf("a= %d\n", a);
}
```

### 分析

### 代码
```c
#include <stdio.h>

int a = 3; // 全局变量

void test() {
    int a = 1; // 局部变量 a，隐藏全局变量
    a += 1;    // a 变为 2
    {
        int a = a + 1; // 使用最内层的局部变量 a 进行计算
        printf("a = %d\n", a); // 打印最内层的 a
    }
    printf("a = %d\n", a); // 打印外层的 a
}

int main(void) {
    test(); // 调用 test 函数
    printf("a = %d\n", a); // 打印全局变量 a
    return 0;
}
```

### 逐行分析
1. **`int a = 3;`**
   - 这里定义了一个全局变量 `a`，并将其初始化为 `3`。全局变量的生命周期从程序开始到结束，作用域是整个文件。

2. **`void test() {...}`**
   - 定义了一个函数 `test`。在这个函数内部，我们会定义几个局部变量 `a`。

3. **`int a = 1;`**
   - 在 `test` 函数内，声明并初始化一个局部变量 `a` 为 `1`。这个局部变量的作用域仅限于 `test` 函数。此时，函数内的局部变量 `a` 遮蔽了全局变量 `a`。

4. **`a += 1;`**
   - 这里将局部变量 `a` 的值增加 `1`，所以局部变量 `a` 的值现在是 `2`。全局变量 `a` 的值仍然是 `3`。

5. **`{ int a = a + 1; ... }`**
   - 进入一个新的作用域，这里又声明了一个新的局部变量 `a`。
   - 这里的 `int a = a + 1;` 的 `a` 在未初始化时，取决于最近的作用域内的 `a`。因为 `a` 在最内层的作用域内，所以这里实际上是使用了最内层的 `a` 来计算，但由于最内层的 `a` 尚未定义，其值是未定义的，因此可能得到一个随机值（如 `32768`）。在 C 语言中，这样的使用可能会导致不可预知的结果。

6. **`printf("a = %d\n", a);`**
   - 这行代码打印出最内层局部变量 `a` 的值，因为它未被初始化，所以打印的是未定义的值（例如 `32768`）。

7. **`printf("a = %d\n", a);`**
   - 这里打印的是 `test` 函数中第一个局部变量 `a`，它的值为 `2`。

8. **`int main(void) {...}`**
   - 程序的主函数，首先调用 `test()` 函数，然后打印全局变量 `a`。

9. **`printf("a = %d\n", a);`**
   - 此时，打印的是全局变量 `a` 的值，即 `3`。由于局部变量的作用域限制，`test` 函数中的变量并不会影响全局变量。

### 输出结果总结
因此，程序的输出依次为：
```
a = 32768
a = 2
a = 3
```

### 输出解释
- **`a = 32768`**: 表示最内层的局部变量 `a` 的未定义值，这个值取决于栈上的随机数据。
- **`a = 2`**: 表示 `test` 函数中的第一个局部变量 `a` 的值，已经被增加到 `2`。
- **`a = 3`**: 表示全局变量 `a` 的值，未受到局部变量的影响，依旧是 `3`。

### 关键概念
- **作用域**：局部变量在其定义的范围内可见，遮蔽外部同名变量。
- **未初始化变量**：使用未初始化变量会导致未定义行为。
- **全局与局部变量**：全局变量在整个程序中可用，而局部变量只在其所在的函数内可用。

在C语言中，全局变量和局部变量的生命周期有显著的区别，主要体现在它们的生存时间和作用范围上。

全局变量

	•	定义：全局变量是在所有函数之外定义的变量，通常位于程序文件的最上方。
	•	生命周期：全局变量的生命周期是从程序开始运行到结束。它们在程序启动时被分配内存，程序结束时释放内存。
	•	作用范围：全局变量可以被整个程序访问，也就是说它在定义所在的文件中都可见，甚至可以通过extern关键字在其他文件中引用。
	•	存储类型：全局变量默认存储在数据段，这段内存通常比栈内存（局部变量使用的）更持久，但存取速度稍慢。

局部变量

	•	定义：局部变量是在函数或代码块内定义的变量。
	•	生命周期：局部变量的生命周期是在定义它的代码块执行时。一般在进入函数或块时分配内存，离开后自动释放。
	•	作用范围：局部变量仅在定义它的函数或代码块内可见，外部无法访问。
	•	存储类型：局部变量通常存储在栈区，栈内存可以在程序运行中不断地分配和释放，访问速度快，但生命周期短暂。


## 4. 内存对不齐

`union`与`struct`各有什么特点呢，你了解他们的内存分配模式吗。

```c
typedef union {
    long l;
    int i[5];
    char c;
} UNION;
typedef struct {
    int like;
    UNION coin;
    double collect;
} STRUCT;
int main(void) {
    printf("sizeof (UNION) = %zu\n", sizeof(UNION)); 
    printf("sizeof (STRUCT) = %zu\n", sizeof(STRUCT));
}
```

### 分析

### 代码回顾
```c
#include <stdio.h>

typedef union {
    long l;
    int i[5];
    char c;
} UNION;

typedef struct {
    int like;
    UNION coin;
    double collect;
} STRUCT;

int main(void) {
    printf("sizeof (UNION) = %zu\n", sizeof(UNION)); 
    printf("sizeof (STRUCT) = %zu\n", sizeof(STRUCT));
}
```

### 1. `sizeof(UNION)`
- **成员大小**：
  - `long l`：通常在现代系统中是 8 字节。
  - `int i[5]`：5 个 `int`，通常是 5 × 4 = 20 字节。
  - `char c`：1 字节。
  
- **最大成员的大小**：由于 `union` 共享内存，所以它的大小为最大成员的大小。这里最大成员是 `int i[5]`（20 字节），但还需要考虑内存对齐。
  
- **内存对齐**：为了提高访问效率，编译器通常会按照类型的对齐要求来对内存进行填充。对于 `long`，一般要求是 8 字节对齐，因此 `UNION` 的大小向上对齐到 24 字节（8 字节的倍数）。因此，`sizeof(UNION)` 输出为 24。

### 2. `sizeof(STRUCT)`
- **成员大小**：
  - `int like`：4 字节。
  - `UNION coin`：24 字节（如上所述）。
  - `double collect`：通常是 8 字节。

- **总大小计算**：
  - 不考虑填充时，结构体成员大小的总和是 4 + 24 + 8 = 36 字节。
  
- **内存对齐**：
  - `STRUCT` 的大小需要满足最严格的对齐要求。这里 `double` 通常要求 8 字节对齐。因此，在 `like` 和 `coin` 之间可能会有 4 字节的填充，使得 `STRUCT` 的总大小为 40 字节（4 + 4（填充） + 24 + 8 = 40）。
  
### 输出结果
因此，程序输出如下：
```
sizeof (UNION) = 24
sizeof (STRUCT) = 40
```

### 总结
- `union` 的大小受最大成员的大小和内存对齐的影响，而 `struct` 的大小是所有成员大小的总和加上必要的填充。
- 通过理解内存对齐和成员的大小，我们可以更好地预测 `sizeof` 操作的结果，尤其是在包含 `union` 和 `struct` 的情况下。

## 5. Bitwise

- 请使用纸笔推导出程序的输出结果。
- 请谈谈你对位运算的理解。

```c
int main(void) {
    unsigned char a = 4 | 7;
    a <<= 3;
    unsigned char b = 5 & 7;
    b >>= 3;
    unsigned char c = 6 ^ 7;
    c = ~c;
    unsigned short d = (a ^ c) << 3;
    signed char e = -63;
    e <<= 2;
    printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, (char)d);
    printf("e: %#x\n", e);
}
```

### 分析

### 1. 程序输出推导

```c
#include <stdio.h>

int main(void) {
    unsigned char a = 4 | 7; // 第一步
    a <<= 3;                 // 第二步
    unsigned char b = 5 & 7; // 第三步
    b >>= 3;                 // 第四步
    unsigned char c = 6 ^ 7; // 第五步
    c = ~c;                  // 第六步
    unsigned short d = (a ^ c) << 3; // 第七步
    signed char e = -63;    // 第八步
    e <<= 2;                 // 第九步
    printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, (char)d);
    printf("e: %#x\n", e);
}
```

#### 步骤分析

1. **第一步**: `unsigned char a = 4 | 7;`
   - `4` 的二进制是 `0000 0100`
   - `7` 的二进制是 `0000 0111`
   - `4 | 7` = `0000 0111` (结果为 `7`)
   - 所以 `a = 7`

2. **第二步**: `a <<= 3;`
   - `7` 的二进制是 `0000 0111`
   - 左移 3 位得到 `0011 1000` (即 56)
   - 所以 `a = 56`

3. **第三步**: `unsigned char b = 5 & 7;`
   - `5` 的二进制是 `0000 0101`
   - `7` 的二进制是 `0000 0111`
   - `5 & 7` = `0000 0101` (结果为 `5`)
   - 所以 `b = 5`

4. **第四步**: `b >>= 3;`
   - `5` 的二进制是 `0000 0101`
   - 右移 3 位得到 `0000 0000` (即 0)
   - 所以 `b = 0`

5. **第五步**: `unsigned char c = 6 ^ 7;`
   - `6` 的二进制是 `0000 0110`
   - `7` 的二进制是 `0000 0111`
   - `6 ^ 7` = `0000 0001` (结果为 `1`)
   - 所以 `c = 1`

6. **第六步**: `c = ~c;`
   - `1` 的二进制是 `0000 0001`
   - 取反得到 `1111 1110` (即 254, 由于是 `unsigned char`)
   - 所以 `c = 254`

7. **第七步**: `unsigned short d = (a ^ c) << 3;`
   - `a = 56`, `c = 254`
   - `56` 的二进制是 `0011 1000`
   - `254` 的二进制是 `1111 1110`
   - `56 ^ 254` = `1100 0110` (即 `198`)
   - `198 << 3` 得到 `198 * 8 = 1584` (但我们只关心最后的值)
   - 所以 `d = 1584`

8. **第八步**: `signed char e = -63;`
   - `-63` 的二进制补码表示是 `1100 0001` (在 8 位中)

9. **第九步**: `e <<= 2;`
   - `1100 0001` 左移 2 位得到 `0000 0000`（最前的两个 1 被移出）
   - 所以 `e` 的值是 `0x4`（在输出中是 `0x4`）

### 输出结果
最终输出为：
```
a: 56, b: 0, c: 254, d: 48
e: 0x4
```

### 2. 位运算的理解
位运算是直接操作整数在内存中的二进制位的运算，它包括与（&）、或（|）、异或（^）、取反（~）、左移（<<）和右移（>>）。位运算的特点包括：

- **高效**：位运算直接在二进制层面操作，因此在某些情况下比算术运算更快。
- **直接操作**：可以直接对某些特定位进行操作，这在低级编程（如嵌入式系统）中尤其重要。
- **灵活性**：可以用于设置、清除或反转特定位。

## 6. 英译汉

请说说下面数据类型的含义，谈谈`const`的作用。
1. `char *const p`。
2. `char const *p`。
3. `const char *p`。

### 分析

### 1. `char *const p`
- **含义**：
  - `p` 是一个指向 `char` 的常量指针。这意味着指针 `p` 的值（即它指向的地址）不能被修改，但可以通过 `p` 修改它指向的 `char` 数据。
- **示例**：
  ```c
  char c = 'A';
  char *const p = &c; // p是一个常量指针，指向c
  *p = 'B';           // 合法，修改了p所指向的数据
  // p = &otherChar;  // 不合法，试图修改p的指向
  ```

### 2. `char const *p`
- **含义**：
  - `p` 是一个指向 `const char` 的指针。这意味着通过指针 `p` 不能修改它指向的 `char` 数据，但指针 `p` 的值（指向的地址）可以被修改。
- **示例**：
  ```c
  const char c = 'A';
  char const *p = &c; // p是一个指向const char的指针
  // *p = 'B';         // 不合法，试图修改p所指向的数据
  p = &otherChar;     // 合法，p可以指向其他地址
  ```

### 3. `const char *p`
- **含义**：
  - 这与 `char const *p` 的含义相同，`p` 是一个指向 `const char` 的指针。指针 `p` 可以指向不同的地址，但不能通过 `p` 修改所指向的数据。
- **示例**：
  ```c
  const char c = 'A';
  const char *p = &c; // p是一个指向const char的指针
  // *p = 'B';         // 不合法，试图修改p所指向的数据
  p = &otherChar;     // 合法，p可以指向其他地址
  ```

### `const` 的作用
`const` 关键字在 C 语言中用于指示某个变量的值不能被修改。具体作用包括：

1. **增强代码的可读性和可维护性**：通过使用 `const`，可以清楚地表明某些变量的值应该保持不变，从而减少意外修改的风险。
2. **提高安全性**：在函数参数中使用 `const` 可以防止意外修改传入的参数，增加代码的安全性。例如：
   ```c
   void printString(const char *str) {
       // str的内容不能被修改
   }
   ```
3. **优化编译器的性能**：编译器可以更好地优化使用 `const` 的变量，因为它知道这些变量的值不会被改变。
4. **支持不可变数据结构**：使用 `const` 可以实现一些不可变数据结构，使代码更加健壮。

## 7. 汉译英

请用变量`p`给出下面的定义:
1. 含有10个指向`int`的指针的数组。
2. 指向含有10个`int`数组的指针。
3. 含有3个「指向函数的指针」的数组，被指向的函数有1个`int`参数并返回`int`。

### 分析

下面是使用变量 `p` 定义所请求的三种类型：

1. **含有10个指向`int`的指针的数组**：
   ```c
   int *p[10];  // p 是一个含有 10 个指向 int 的指针的数组
   ```

2. **指向含有10个`int`数组的指针**：
   ```c
   int (*p)[10];  // p 是一个指向含有 10 个 int 的数组的指针
   ```

3. **含有3个「指向函数的指针」的数组，被指向的函数有2个`int`参数并返回`int`**：
   ```c
   int (*p[3])(int, int);  // p 是一个含有 3 个指向函数的指针的数组，这些函数接受一个 int 参数并返回 int
   ```

## 8. 混乱中建立秩序

你对排序算法了解多少呢?  
请谈谈你所了解的排序算法的思想、稳定性、时间复杂度、空间复杂度。

提示：动动你的小手敲出来更好哦~

### 分析

排序算法是计算机科学中的一个基本主题，其目的是将一组数据按照特定的顺序（通常是升序或降序）进行排列。以下是一些常见的排序算法的思想、稳定性、时间复杂度和空间复杂度的概述。

### 1. 冒泡排序 (Bubble Sort)
- **思想**：通过重复遍历待排序的数组，比较相邻的元素并交换它们的顺序，直到没有更多的交换需要进行。
- **稳定性**：稳定（相同元素的相对顺序不变）。
- **时间复杂度**：
  - 最好情况：O(n)
  - 平均情况：O(n^2)
  - 最坏情况：O(n^2)
- **空间复杂度**：O(1)

### 2. 选择排序 (Selection Sort)
- **思想**：每次从未排序的部分中选择最小（或最大）元素，放到已排序的部分末尾。
- **稳定性**：不稳定（可能改变相同元素的相对顺序）。
- **时间复杂度**：
  - 最好情况：O(n^2)
  - 平均情况：O(n^2)
  - 最坏情况：O(n^2)
- **空间复杂度**：O(1)

### 3. 插入排序 (Insertion Sort)
- **思想**：将数组分为已排序和未排序两部分，逐个将未排序的元素插入到已排序的部分中。
- **稳定性**：稳定。
- **时间复杂度**：
  - 最好情况：O(n)
  - 平均情况：O(n^2)
  - 最坏情况：O(n^2)
- **空间复杂度**：O(1)

### 4. 归并排序 (Merge Sort)
- **思想**：采用分治法，将数组分成两半，分别排序后再合并。
- **稳定性**：稳定。
- **时间复杂度**：
  - 最好情况：O(n log n)
  - 平均情况：O(n log n)
  - 最坏情况：O(n log n)
- **空间复杂度**：O(n)（需要额外的存储空间用于合并）

### 5. 快速排序 (Quick Sort)
- **思想**：选择一个“基准”元素，将数组划分为两个部分，使得一部分小于基准，另一部分大于基准，然后递归排序这两部分。
- **稳定性**：不稳定。
- **时间复杂度**：
  - 最好情况：O(n log n)
  - 平均情况：O(n log n)
  - 最坏情况：O(n^2)（当数组已经排序或几乎排序时）
- **空间复杂度**：O(log n)（递归调用栈空间）

### 6. 堆排序 (Heap Sort)
- **思想**：将数组构建成最大堆（或最小堆），然后将根节点（最大或最小）与最后一个元素交换，并重新调整堆。
- **稳定性**：不稳定。
- **时间复杂度**：
  - 最好情况：O(n log n)
  - 平均情况：O(n log n)
  - 最坏情况：O(n log n)
- **空间复杂度**：O(1)

### 7. 基数排序 (Radix Sort)
- **思想**：将整数按位分为多个关键字，从低位到高位依次进行排序，通常结合桶排序。
- **稳定性**：稳定。
- **时间复杂度**：O(kn)，其中 k 是数字的位数。
- **空间复杂度**：O(n + k)。

### 简单写一个冒泡排序

#include <stdio.h>

```c
// 冒泡排序函数
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        // 在每次迭代中，假设数组已经排序好
        int swapped = 0; // 用于优化，标记是否有交换发生
        for (int j = 0; j < n - i - 1; j++) {
            // 比较相邻元素，如果前一个比后一个大，则交换它们
            if (arr[j] > arr[j + 1]) {
                // 交换 arr[j] 和 arr[j + 1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = 1; // 标记有交换发生
            }
        }
        // 如果没有交换，说明数组已经排序好，可以提前结束
        if (!swapped) {
            break;
        }
    }
}

// 测试冒泡排序
int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("原数组: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    bubbleSort(arr, n);

    printf("排序后数组: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```


## 9. 手脑并用

请实现ConvertAndMerge函数：  
拼接输入的两个字符串，并翻转拼接后得到的新字符串中所有字母的大小写。

提示:你需要为新字符串分配空间。

```c
char* convertAndMerge(/*补全签名*/);
int main(void) {
    char words[2][20] = {"Welcome to Xiyou ", "Linux Group 2022"};
    printf("%s\n", words[0]);
    printf("%s\n", words[1]);
    char *str = convertAndMerge(words);
    printf("str = %s\n", str);
    free(str);
}
```

### 分析

下面是 `convertAndMerge` 函数的实现，该函数将输入的两个字符串拼接在一起，并将拼接后的字符串中的所有字母的大小写翻转。注意，我们为新的字符串分配了足够的空间。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// 函数声明
char* convertAndMerge(char words[2][20]);

// 函数实现
char* convertAndMerge(char words[2][20]) {
    // 计算两个字符串的总长度
    int totalLength = strlen(words[0]) + strlen(words[1]) + 1; // +1 for null terminator

    // 为新的字符串分配内存
    char *mergedStr = (char *)malloc(totalLength * sizeof(char));
    if (mergedStr == NULL) {
        return NULL; // 检查内存分配是否成功
    }

    // 拼接两个字符串
    strcpy(mergedStr, words[0]);
    strcat(mergedStr, words[1]);

    // 翻转大小写
    for (int i = 0; mergedStr[i] != '\0'; i++) {
        if (isalpha(mergedStr[i])) { // 检查是否为字母
            if (islower(mergedStr[i])) {
                mergedStr[i] = toupper(mergedStr[i]); // 转换为大写
            } else {
                mergedStr[i] = tolower(mergedStr[i]); // 转换为小写
            }
        }
    }

    return mergedStr; // 返回拼接和翻转后的字符串
}

int main(void) {
    char words[2][20] = {"Welcome to Xiyou ", "Linux Group 2022"};
    printf("%s\n", words[0]);
    printf("%s\n", words[1]);
    char *str = convertAndMerge(words);
    printf("str = %s\n", str);
    free(str); // 释放动态分配的内存
    return 0;
}
```

### 程序说明
1. **convertAndMerge 函数**:
   - 计算输入两个字符串的总长度（包括空字符）。
   - 使用 `malloc` 为新的字符串分配内存。
   - 使用 `strcpy` 和 `strcat` 拼接两个字符串。
   - 遍历拼接后的字符串，使用 `isalpha` 检查每个字符是否为字母，并用 `toupper` 和 `tolower` 进行大小写转换。

2. **主函数**:
   - 定义两个字符串，打印它们。
   - 调用 `convertAndMerge` 函数并打印拼接和翻转后的结果。
   - 最后释放动态分配的内存以避免内存泄漏。

### 输出示例
运行该程序后，输出结果将显示原字符串和处理后的字符串：
```
Welcome to Xiyou 
Linux Group 2022
str = wELCOME TO xiyOU lINUX gROUP 2022
```

## 10. 给你我的指针，访问我的心声

程序的输出有点奇怪，请尝试解释一下程序的输出吧。

```c
int main(int argc, char **argv) {
    int arr[5][5];
    int a = 0;
    for (int i = 0; i < 5; i++) {
        int *temp = *(arr + i);
        for (; temp < arr[5]; temp++) *temp = a++;
    }
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            printf("%d\t", arr[i][j]);
        }
    }
}
```

### 分析

### 程序分析

1. **数组定义**:
   ```c
   int arr[5][5];
   ```
   这行代码定义了一个 5x5 的二维数组，实际内存中会占用 25 个整数的空间。

2. **初始化变量**:
   ```c
   int a = 0;
   ```
   变量 `a` 被初始化为 0，用于在接下来的循环中给数组元素赋值。

3. **外层循环**:
   ```c
   for (int i = 0; i < 5; i++) {
       int *temp = *(arr + i);
   ```
   这个循环迭代 `i` 从 0 到 4，每次取出 `arr[i]` 的首地址并赋给 `temp`。这段代码的意图是对二维数组的每一行进行赋值。

4. **内层循环**:
   ```c
   for (; temp < arr[5]; temp++) *temp = a++;
   ```
   这里 `temp < arr[5]` 是一个潜在的错误。`arr[5]` 实际上是访问了数组边界外的内存，因为有效的索引范围是 0 到 4。`arr[5]` 实际上是 `arr` 数组后面的一个地址，访问这个地址是未定义的行为。

   正确的做法应该是使用 `temp < arr[i] + 5`，这样可以确保只在当前行的范围内进行访问。

5. **输出数组**:
   ```c
   for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
           printf("%d\t", arr[i][j]);
       }
   }
   ```
   这个嵌套循环打印出整个数组的内容。

### 输出解释

由于内层循环使用了 `temp < arr[5]`，在 `temp` 越过数组 `arr` 的有效范围后，它会继续向下读取内存，直到遇到不再属于该程序的内存区域。这就是为什么程序打印出一些看似无意义的数字，如 25, 26, 27 等等，它们实际上是后续内存地址的内容。

### 修复代码

为了避免这种未定义的行为，可以修改内层循环如下：

```c
for (int i = 0; i < 5; i++) {
    int *temp = arr[i]; // 或者 int *temp = *(arr + i);
    for (; temp < arr[i] + 5; temp++) *temp = a++;
}
```

### 结论

由于原始代码中的数组访问越界，导致程序行为不可预测，输出的结果包含了未初始化的或已释放的内存数据。修复该问题后，程序应该可以正常输出一个 5x5 的整型数组，值为从 0 到 24 的整数。

## 11. 奇怪的参数

你了解argc和argv吗？  
直接运行程序argc的值为什么是1？  
程序会出现死循环吗？

```c
#include <stdio.h>
int main(int argc, char **argv) {
    printf("argc = %d\n", argc);
    while (1) {
        argc++;
        if (argc < 0) {
            printf("%s\n", (char *)argv[0]);
            break;
        }
    }
}
```

### 分析

### `argc` 和 `argv` 介绍

- `argc`（argument count）表示命令行参数的数量，包括程序本身的名称。
- `argv`（argument vector）是一个字符串数组，包含所有命令行参数。`argv[0]` 是程序的名称，`argv[1]` 到 `argv[argc - 1]` 是其他参数。

### 运行程序时 `argc` 的值

在这个特定程序中，`argc` 的值为 1，因为没有提供额外的命令行参数。如果你从命令行运行这个程序，比如输入 `./program`，只有程序名称被传递，所以 `argc` 是 1。

### 程序是否会出现死循环

该程序的结构如下：

```c
while (1) {
    argc++;
    if (argc < 0) {
        printf("%s\n", (char *)argv[0]);
        break;
    }
}
```

1. **死循环**：
   - `while (1)` 创建了一个无限循环。
   - 在每次循环中，`argc` 会自增。由于 `argc` 是一个整型，且初始值为 1，随着每次循环它的值将不断增加，直到达到整型的最大值。

2. **条件判断**：
   - `if (argc < 0)`：这个条件会在 `argc` 溢出到负数时才会为真。然而，`argc` 是一个 `int` 类型，因此在增加到最大值后再继续增加会导致溢出，进入负数（通常是 `-2147483648`，在 32 位系统中）。

3. **程序行为**：
   - 由于 `argc` 从 1 开始不断增加，理论上会在某个时候达到整型的最大值并导致溢出。因此程序不会在正常情况下造成死循环，但在达到最大值后会触发条件判断并打印 `argv[0]`，然后 `break` 退出循环。

### 总结

- 当程序运行时，`argc` 的值是 1，因为没有传递任何额外参数。
- 程序不会造成死循环，而是在 `argc` 溢出后触发条件判断，打印程序名称并退出循环。注意，这种方式并不是一个好的实践，通常不应该在程序中使用无限循环与溢出条件进行控制。

## 12. 奇怪的字符

程序的输出有点奇怪，请尝试解释一下程序的输出吧。

```c
int main(int argc, char **argv) {
    int data1[2][3] = {{0x636c6557, 0x20656d6f, 0x58206f74},
                       {0x756f7969, 0x6e694c20, 0x00000000}};
    int data2[] = {0x47207875, 0x70756f72, 0x32303220, 0x00000a32};
    char *a = (char *)data1;
    char *b = (char *)data2;
    char buf[1024];
    strcpy(buf, a);
    strcat(buf, b);
    printf("%s \n", buf);
}
```

### 分析

### 代码分析
```c
int main(int argc, char **argv) {
    int data1[2][3] = {{0x636c6557, 0x20656d6f, 0x58206f74},
                       {0x756f7969, 0x6e694c20, 0x00000000}};
    int data2[] = {0x47207875, 0x70756f72, 0x32303220, 0x00000a32};
    char *a = (char *)data1;
    char *b = (char *)data2;
    char buf[1024];
    strcpy(buf, a);
    strcat(buf, b);
    printf("%s \n", buf);
}
```

1. **数据定义部分**
   ```c
   int data1[2][3] = {{0x636c6557, 0x20656d6f, 0x58206f74},
                      {0x756f7969, 0x6e694c20, 0x00000000}};
   int data2[] = {0x47207875, 0x70756f72, 0x32303220, 0x00000a32};
   ```

   - `data1` 和 `data2` 是两个整数数组，每个元素使用了十六进制数来存储一些字符的编码。  
   - **小端模式**：在小端模式的系统中（如大多数 x86 架构），每个 `int`（4字节）的存储顺序是从最低字节到最高字节，这使得 0x636c6557 在内存中按以下顺序存储：`57 65 6c 63`。这些数字分别表示 ASCII 字符 `W`, `e`, `l`, `c`。

   根据小端模式解读每个数，我们可以把 `data1` 和 `data2` 解码成 ASCII 字符串：

   - `data1` 解码为：
     - `0x636c6557` -> `W e l c`
     - `0x20656d6f` -> `o m e  `
     - `0x58206f74` -> `t o X`
     - `0x756f7969` -> `i y o u`
     - `0x6e694c20` -> `L i n `
     - `0x00000000` -> 字符串结束符 `\0`

     整体解码成 `"Welcome to Xiyou Lin"`。

   - `data2` 解码为：
     - `0x47207875` -> `G r o u`
     - `0x70756f72` -> `p 202`
     - `0x32303220` -> ` 0 2`
     - `0x00000a32` -> 字符串结束符 `\0`

     整体解码为 `"Group 2022"`。

2. **指针转换和字符串操作**
   ```c
   char *a = (char *)data1;
   char *b = (char *)data2;
   ```
   - `a` 和 `b` 被声明为 `char *` 类型的指针，并且通过强制转换指向 `data1` 和 `data2` 的起始地址。
   - 这意味着 `a` 和 `b` 分别指向 `data1` 和 `data2` 的数据内容，可以将它们视为 C 字符串（尽管它们实际是 `int` 数组）。

3. **字符串拼接**
   ```c
   char buf[1024];
   strcpy(buf, a);
   strcat(buf, b);
   ```
   - 使用 `strcpy` 将 `a` 所指向的字符串内容（即 `data1` 代表的字符串）复制到 `buf` 中。
   - 然后使用 `strcat` 将 `b` 所指向的字符串内容（即 `data2` 代表的字符串）连接到 `buf` 的末尾。

4. **打印输出**
   ```c
   printf("%s \n", buf);
   ```
   - `buf` 最终包含了拼接后的字符串 `"Welcome to Xiyou Linux Group 2022"`。

### 总结
程序最终输出的是组合了 `data1` 和 `data2` 的内容形成的字符串："**Welcome to Xiyou Linux Group 2022**"。

### `strcpy()`函数

`strcpy()` 函数是 C 语言中的一个字符串处理函数，定义在 `<string.h>` 头文件中。它的主要作用是将一个字符串（源字符串）复制到另一个字符串（目标字符串）。

#### 函数原型

```c
char *strcpy(char *dest, const char *src);
```

#### 参数说明

- **`dest`**: 目标字符串，复制到这个字符串的内容。此字符串必须有足够的空间来存放源字符串的内容，包括结束的空字符（`\0`）。
- **`src`**: 源字符串，从这个字符串复制内容。

#### 返回值

- 返回 `dest` 的指针，即目标字符串的地址。

#### 作用

- `strcpy()` 函数将 `src` 字符串的内容复制到 `dest` 字符串，并在 `dest` 的末尾自动添加一个空字符 (`'\0'`) 来标识字符串的结束。

#### 示例

下面是一个简单的使用 `strcpy()` 的示例：

```c
#include <stdio.h>
#include <string.h>

int main() {
    char src[] = "Hello, World!"; // 源字符串
    char dest[50];                // 目标字符串

    strcpy(dest, src);            // 将 src 复制到 dest

    printf("结果: %s\n", dest);   // 输出: 结果: Hello, World!

    return 0;
}
```

#### 注意事项

1. **缓冲区溢出**: 确保目标字符串 `dest` 有足够的空间来存储源字符串的内容，否则会导致缓冲区溢出，可能会引发未定义行为。
2. **字符串结束符**: `strcpy()` 会在目标字符串的末尾添加一个空字符，以确保新字符串正确结束。
3. **原地修改**: `strcpy()` 直接修改目标字符串，源字符串的内容保持不变。

#### 总结

`strcpy()` 是一个用于字符串复制的简单而有效的工具，但在使用时必须小心处理缓冲区和字符串结束符，以避免潜在的错误。为了安全起见，建议在实际应用中考虑使用 `strncpy()` 或其他安全的字符串处理函数，以防止缓冲区溢出的问题。

### `strcat()`函数

`strcat()` 函数是 C 语言中的一个字符串处理函数，定义在 `<string.h>` 头文件中。它的主要作用是将一个字符串（源字符串）附加到另一个字符串（目标字符串）之后。

#### 函数原型

```c
char *strcat(char *dest, const char *src);
```

#### 参数说明

- **`dest`**: 目标字符串，即要将内容附加到的字符串。这个字符串必须有足够的空间来存放追加后的内容。
- **`src`**: 源字符串，即要附加到目标字符串后的字符串。

#### 返回值

- 返回 `dest` 的指针，即目标字符串的地址。

#### 作用

- `strcat()` 函数将 `src` 字符串的内容添加到 `dest` 字符串的末尾，并在 `dest` 的末尾自动添加一个空字符 (`'\0'`) 来标识字符串的结束。

#### 示例

下面是一个简单的使用 `strcat()` 的示例：

```c
#include <stdio.h>
#include <string.h>

int main() {
    char dest[50] = "Hello, ";  // 目标字符串
    char src[] = "World!";      // 源字符串

    strcat(dest, src);          // 将 src 附加到 dest 之后

    printf("结果: %s\n", dest); // 输出: 结果: Hello, World!

    return 0;
}
```

#### 注意事项

1. **缓冲区溢出**: 确保目标字符串 `dest` 有足够的空间来存储附加后的内容，否则会导致缓冲区溢出，可能会引发未定义行为。
2. **字符串结束符**: `strcat()` 会在目标字符串的末尾添加一个空字符，以确保新字符串正确结束。
3. **原地修改**: `strcat()` 直接修改目标字符串，原来的内容会被保留在目标字符串的开头部分。

#### 总结

`strcat()` 是一个用于字符串拼接的简单而有效的工具，但在使用时必须小心处理缓冲区和字符串结束符，以避免潜在的错误。

## 13. 小试宏刀

- 请谈谈你对`#define`的理解。
- 请尝试着解释程序的输出。

```c
#define SWAP(a, b, t) t = a; a = b; b = t
#define SQUARE(a) a *a
#define SWAPWHEN(a, b, t, cond) if (cond) SWAP(a, b, t)
int main() {
    int tmp;
    int x = 1;
    int y = 2;
    int z = 3;
    int w = 3;
    SWAP(x, y, tmp);
    printf("x = %d, y = %d, tmp = %d\n", x, y, tmp);
    if (x > y) SWAP(x, y, tmp);
    printf("x = %d, y = %d, tmp = %d\n", x, y, tmp);
    SWAPWHEN(x, y, tmp, SQUARE(1 + 2 + z++ + ++w) == 100);
    printf("x = %d, y = %d\n", x, y, tmp);
    printf("z = %d, w = %d, tmp = %d\n", z, w, tmp);
}
```

### 分析

### 对 `#define` 的理解

`#define` 是 C 语言中的一个预处理指令，用于定义宏。宏是一种文本替换机制，可以在编译期间将代码中的某些部分替换为指定的文本。这种替换可以提高代码的可读性和可维护性，并且可以减少代码重复。

1. **简化代码**: 通过使用宏，可以简化常用操作的书写，例如在本例中定义了 `SWAP` 和 `SQUARE` 宏来进行变量的交换和计算平方。
2. **条件编译**: 宏也可用于条件编译，使得某些代码块仅在特定条件下被编译。
3. **类型安全性**: 宏在替换时不会进行类型检查，可能会导致一些潜在的错误，因此使用时需要小心。

### 程序输出解释

我们逐步分析程序的执行过程及输出：

1. **定义变量**:
   ```c
   int tmp;
   int x = 1;
   int y = 2;
   int z = 3;
   int w = 3;
   ```
   - `tmp` 用于交换时存储临时值。
   - 初始化 `x` 为 1，`y` 为 2，`z` 和 `w` 都为 3。

2. **执行 `SWAP(x, y, tmp)`**:
   ```c
   SWAP(x, y, tmp);
   ```
   - 替换为 `tmp = x; x = y; y = tmp;`
   - 先将 `x` 的值（1）赋给 `tmp`，然后将 `y` 的值（2）赋给 `x`，最后将 `tmp` 的值（1）赋给 `y`。
   - 结果：`x = 2, y = 1, tmp = 1`

3. **输出第一个 `printf`**:
   ```c
   printf("x = %d, y = %d, tmp = %d\n", x, y, tmp);
   ```
   - 输出：`x = 2, y = 1, tmp = 1`

4. **执行条件语句**:
   ```c
   if (x > y) SWAP(x, y, tmp);
   ```
   - 此时 `x` 是 2，`y` 是 1，因此条件成立，执行 `SWAP(x, y, tmp)`。
   - 结果：`tmp = 2; x = 1; y = 2;`（此时 `tmp` 存储的是 `y` 的值 1）

5. **输出第二个 `printf`**:
   ```c
   printf("x = %d, y = %d, tmp = %d\n", x, y, tmp);
   ```
   - 输出：`x = 1, y = 2, tmp = 2`

6. **执行 `SWAPWHEN(x, y, tmp, SQUARE(1 + 2 + z++ + ++w) == 100)`**:
   - `SQUARE(1 + 2 + z++ + ++w)` 会被替换为 `1 + 2 + z++ + ++w * 1 + 2 + z++ + ++w`，计算过程：
     - `z++` 后，`z` 变为 4（原来是 3，后加 1）。
     - `++w` 将 `w` 先加 1，变为 4。
     - 整个表达式的值为 `1 + 2 + 3 + 4 = 10`，因此条件 `10 == 100` 为假。
   - 由于条件不成立，`SWAP` 不会被执行，`x` 和 `y` 保持不变。

7. **输出第三个 `printf`**:
   ```c
   printf("x = %d, y = %d\n", x, y);
   ```
   - 输出：`x = 2, y = 2`

8. **输出最后一个 `printf`**:
   ```c
   printf("z = %d, w = %d, tmp = %d\n", z, w, tmp);
   ```
   - 输出：`z = 5, w = 5, tmp = 2`

### 总结输出结果
最终输出为：
```
x = 2, y = 1, tmp = 1
x = 1, y = 2, tmp = 2
x = 2, y = 2
z = 5, w = 5, tmp = 2
```

因此，在这段代码中，利用了宏定义和简单的条件判断来交换变量的值，并展示了对变量值变化的控制。

## 14. GNU/Linux命令 (选做)

你知道以下命令的含义和用法吗：

注：
嘿！你或许对Linux命令不是很熟悉，甚至你没听说过Linux。  
但别担心，这是选做题，不会对你的面试产生很大的影响！  
了解Linux是加分项，但不了解也不扣分哦！
- `ls`
- `rm`
- `whoami`

请问你还了解哪些GNU/Linux的命令呢。

### 解答

### 1. `ls`
- **含义**: 列出目录内容。
- **用法**: `ls [选项] [路径]`
- **常用选项**:
  - `-l`: 以长格式列出文件信息（包括权限、所有者、文件大小、修改时间等）。
  - `-a`: 显示所有文件，包括以`.`开头的隐藏文件。
  - `-h`: 以人类可读的格式显示文件大小（如 KB、MB）。

### 2. `rm`
- **含义**: 删除文件或目录。
- **用法**: `rm [选项] [文件]`
- **常用选项**:
  - `-r`: 递归删除目录及其内容。
  - `-f`: 强制删除文件，不显示警告。
  - `-i`: 删除前提示确认。

### 3. `whoami`
- **含义**: 显示当前用户的用户名。
- **用法**: `whoami`
- **示例**: 如果你以用户“alice”登录，运行此命令将显示“alice”。

### 其他常用的GNU/Linux命令

- **`cd`**: 切换目录。
  - 用法: `cd [路径]`
  - 示例: `cd /home/user`。

- **`pwd`**: 显示当前工作目录的完整路径。
  - 用法: `pwd`

- **`mkdir`**: 创建新目录。
  - 用法: `mkdir [目录名]`
  - 示例: `mkdir new_folder`。

- **`cp`**: 复制文件或目录。
  - 用法: `cp [源] [目标]`
  - 示例: `cp file.txt copy_file.txt`。

- **`mv`**: 移动文件或重命名。
  - 用法: `mv [源] [目标]`
  - 示例: `mv old_name.txt new_name.txt`。

- **`cat`**: 连接文件并打印到标准输出。
  - 用法: `cat [文件]`
  - 示例: `cat file.txt`。

- **`echo`**: 显示一段文本或变量的值。
  - 用法: `echo [文本]`
  - 示例: `echo "Hello, World!"`。

- **`man`**: 查看命令的手册页。
  - 用法: `man [命令]`
  - 示例: `man ls`。

- **`chmod`**: 改变文件或目录的权限。
  - 用法: `chmod [选项] [权限] [文件]`
  - 示例: `chmod 755 script.sh`。

- **`top`**: 动态显示系统进程和资源使用情况。

- **`grep`**: 搜索文件中的文本。
  - 用法: `grep [模式] [文件]`
  - 示例: `grep "hello" file.txt`。

> 恭喜你做到这里！你的坚持战胜了绝大多数看到这份试题的同学。  
> 或许你自己对答题的表现不满意,但别担心，请自信一点呐。  
> 坚持到达这里已经证明了你的优秀。  
> 还在等什么,快带上你的笔记本电脑，来FZ103面试吧!